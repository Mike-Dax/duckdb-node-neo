import sys
import pycparser

# those functions return promises asynchronously since they may block and/or do IO
async_functions = ['duckdb_open', 'duckdb_open_ext', 'duckdb_close', 'duckdb_connect', 'duckdb_interrupt', 'duckdb_disconnect', 'duckdb_query', 'duckdb_prepare', 'duckdb_execute_prepared', 'duckdb_stream_fetch_chunk', 'duckdb_execute_tasks', 'duckdb_appender_create', 'duckdb_appender_flush', 'duckdb_appender_close', 'duckdb_appender_destroy', 'duckdb_execute_prepared', 'duckdb_extract_statements', 'duckdb_prepare_extracted_statement', 'duckdb_execute_pending']

def typename(decl):
    const = ''
    if hasattr(decl, 'quals') and 'const' in decl.quals:
        const = 'const '
    if isinstance(decl, pycparser.c_ast.TypeDecl):
        return const + typename(decl.type)
    elif isinstance(decl, pycparser.c_ast.PtrDecl):
        return const + typename(decl.type) + '*'
    elif isinstance(decl, pycparser.c_ast.IdentifierType):
        return decl.names[0].replace('_Bool', 'bool')
    else:
       raise ValueError(decl)

class FuncDefVisitor(pycparser.c_ast.NodeVisitor):
    result = ''
    def visit_FuncDecl(self, node):
       name = None
       ret = typename(node.type)

       args = []
       if isinstance(node.type, pycparser.c_ast.TypeDecl):
           name = node.type.declname
       elif isinstance(node.type, pycparser.c_ast.PtrDecl):
           name = node.type.type.declname
       else:
           raise ValueError(node.type)


       if node.args:
           for p in node.args.params:
               args.append(typename(p.type))

       if name == '__routine':
           return # ??

       if 'replacement' in name:
           return # ??

       if 'delete_callback' in name:
           return # ??


       if 'table_function' in name:
           return # TODO

       if 'arrow' in name:
           return # TODO

       register_name = name.replace('duckdb_', '')
       #print(f"{ret} {name} ({', '.join(args)})")
       print(f"{name}")

       n_args = len(args)
       args.append(name)
       asyncstr = ''
       if name in async_functions:
           asyncstr = 'Async'
       voidstr = ''
       if ret == 'void':
           voidstr = 'Void'
       else:
           args.insert(0, ret)
       arg_str = ', '.join(args)

       self.result += f'exports.Set(String::New(env, "{register_name}"), Function::New<{asyncstr}FunctionWrapper{n_args}{voidstr}<{arg_str}>>(env));\n'

def create_func_defs(filename):
    # produce input like so: gcc -E -D__builtin_va_list=int src/duckdb/src/include/duckdb.h > dd.h

    ast = pycparser.parse_file(filename, use_cpp=False)

    v = FuncDefVisitor()
    v.visit(ast)
    return v.result

if __name__ == "__main__":
    # TODO call preprocessor and create temp file header
    out = open('src/duckdb_node_generated.cpp', 'wb')
    out.write('// This file is generated by generate-wrapper.py, please do not edit\n\nstatic void RegisterGenerated(Env env, Object exports){\n'.encode())
    out.write(create_func_defs(sys.argv[1]).encode())
    out.write('}\n'.encode())
